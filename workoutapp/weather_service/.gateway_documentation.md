# Weather service
We plan to display the current time when a user thinks about doing an exercise that takes place outside. To display data we have to load it from some ware in our case we choose [weatherapi.com](weatherapi.com) because it offers the best free plan in comparison to others.

## Requirements
1. The backend should cache the data in some shape or form to reduce the direct requests to the weather API. This requirement was set to increase the response time during normal usage and to reduce the total number of connections to the api. The free plan for the API usage has a restriction of 20_000 requests per month.
2. The data source should be exchangeable. This requirement will in our case mostly be used for testing. However, this feature is also useful if we want to switch to a different service with better conditions in the future.
3. The system should not be effected by changes from the data provider. API providers have the freedom to change the format of the provided data. We want to prevent any dependencies to the format of api data.
4. The backend should be testable.

## Design pattern
These requirements can all be met by the _gateway pattern_. This pattern is a wrapper pattern that takes an external resource and translates it for the use in another system [vgl. Fowler 2011, S. 466f].

## Implementation
Gateways are often created with the use of code generation [vgl. Fowler 2011, S. 467]. We've decided to avoid code generation to include our own functionality and to learn more about this design pattern during the implementation.

The most basic form of this gateway just requests the data and translates it to a different object that is defined by us and only contains necessary information. This basic implementation fulfils the requirements 2 and 3 (see ##Requirements). The requirement 4 can be met by making the data source exchangeable and support the input of a file or a different data source. 

The first requirement is probably the hardest one because it is not directly a part of the design pattern. We plan to implement this by saving the API response in our database. A request to our weather service would first of all check if the data in the database is fresh enough and suitable for the requested location. The gateway will return the saved data instead of requesting new data if these requirements are fulfilled. The database is basically just another data source from the view of the gateway.

```
+-----------------------------+
| WeatherDataSource_Interface |
+-----------------------------+

    +----------------------+
    | DatabaseDataSource   | <-
    +----------------------+   \
                                \   ##########################     |
    +----------------------+      0 #                        #     |
    | WeatherApiDataSource | <--- 1 #   WeatherDataGateway   # <-- | Rest of the application
    +----------------------+        #                        #     |
                                    ##########################     |
    +----------------------+
    | TestDataSource       |
    | (Only in test mode)  |
    +----------------------+
```

The current description doesn't define how the database receives the newly fetched data. One option would be to have the `WeatherDataGateway` save the fetched data to the database. However, this would increase complexity and make this connection mandatory. We will therefore use the _listener pattern_ to increase _loose coupling_. The gateway will define an interface that pushes the new fetched data to all listeners. The `DatabaseDataSource` will subscribe to this function. This listener pattern might also be used for tests to insure that the delivered data has the expected format

[Fowler 2011]: Source

// This is currently a mapper, I see this. Now how due I make this into a gateway?